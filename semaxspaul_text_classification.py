# -*- coding: utf-8 -*-
"""semaxspaul_text_classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ehs7u5wp0JLwfMd9IFDSHfbPYV2q1S_l

## TEXT CLASSIFICATION OF MOVIE REVIEWS
In this notebook I aim to successfully classify movie reviews as positive or negative using the text of the review.

> Data Acquisition Credit:
[Learning Word Vectors for Sentiment Analysis](https://aclanthology.org/P11-1015) (Maas et al., ACL 2011)

>> Code by:
@semaxspaul
"""

import tensorflow as tf
from tensorflow import keras
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from notebook.services.config import ConfigManager
cm = ConfigManager().update('notebook', {'limit_output': 100})

# Loading movie review data using the 'keras' API by tensorflow
reviews_data = keras.datasets.imdb

"""> Pre-Processing Data"""

# Splitting data into training and testing sets
(train_data, train_labels), (test_data, test_labels) = reviews_data.load_data(num_words=200000)

# Word mapping Retrival
word_index = reviews_data.get_word_index()

# Review Editting
word_index = {key:value+3 for key, value in word_index.items()}
word_index["<PAD>"] = 0
word_index["<START>"] = 1
word_index["<UNK>"] = 2
word_index["<UNUSED>"] = 3

# Reversing the word_index dictionary
reverse_word_index = dict([(value, key) for (key, value) in word_index.items()])

# Regenerating actual worded review
def decode_review(text):
  return " ".join([reverse_word_index.get(i, "?") for i in text])

# Setting a fixed length for all reviews
train_data = keras.preprocessing.sequence.pad_sequences(train_data, value=word_index["<PAD>"], padding="post", maxlen=250)
test_data = keras.preprocessing.sequence.pad_sequences(test_data, value=word_index["<PAD>"], padding="post", maxlen=250)

"""> Developing Model"""

from keras.api._v2.keras import activations
model = keras.Sequential()
model.add(keras.layers.Embedding(200000, 16))
model.add(keras.layers.GlobalAveragePooling1D())
model.add(keras.layers.Dense(16, activation='relu'))
model.add(keras.layers.Dense(1, activation='sigmoid'))

model.summary()

# Defining model metrics and initial hyperparameters
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# creating a validation set
val_data = train_data[:10000]
train_data = train_data[10000:]

val_labels = train_labels[:10000]
train_labels = train_labels[10000:]

# Fitting the model
model.fit(train_data, train_labels,
          epochs=40, 
          batch_size=512, 
          validation_data=(val_data, val_labels),
          verbose=1)

# Model Evaluation
results = model.evaluate(test_data, test_labels)

print(results)

"""> Model Sample Test"""

test_review = test_data[0]
predict = model.predict([test_review.reshape(-1,1)])
print(f"Review: \n{decode_review(test_review)}")
print(f"Sentiment Prediction: {str(round(predict[0][0], 2))}")
print(f"Actual Sentiment: {test_labels[0]}")
print(results)

"""> Saving the Model"""

# Saving this model
model.save('semaxspaul_movie_review_sentiment.h5')

"""> Testing the model on external data
>> I obtained a (10/10) movie review on Blank Panther Wakanda forever 2022 and saved it in ***'external_data_test.txt'*** file
>>> Link: https://www.imdb.com/review/rw8669414/?ref_=tt_urv 
"""

# Loading the model
review_model = keras.models.load_model('/content/semaxspaul_movie_review_sentiment.h5')

# Function to encode a review
def encode_review(text):
  # 1 corresponds to <START>
  encoded_text = [1]

  for word in text:
    if word.lower() in word_index:
      encoded_text.append(word_index[word.lower()])
    else:
      # 2 corresponds to unknown words <UNK>
      encoded_text.append(2)

  return encoded_text

# Preprocessing the external data
with open('/content/external_data_test.txt', encoding='utf-8') as f:
  for line in f.readlines():
    new_line = line.replace(',','').replace('.','').replace('(','').replace(')','').replace(':','').replace('*','').replace('\"','').strip().split()
    encoded = encode_review(new_line)
    encoded = keras.preprocessing.sequence.pad_sequences([encoded], value=word_index["<PAD>"], padding="post", maxlen=250)
    sentiment_prediction = review_model.predict(encoded)
    print(f"Review: \n{line}")
    print(f"Encoded Review: \n{encoded}\n")
    print(f"Sentiment Prediction: {str(round(sentiment_prediction[0][0], 2))}")
    print(f"Actual Sentiment: Positive (1) ")

"""The model predicted the sentiment of the review as expected."""

